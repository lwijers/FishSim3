# === PROJECT TABLE OF CONTENTS (57 files) ===
# Version: PROJECT_EXPORT_v1.4
#  - export_script.py
#  - engine\__init__.py
#  - engine\adapters\__init__.py
#  - engine\app\__init__.py
#  - engine\app\boot.py
#  - engine\app\main.py
#  - engine\ecs\__init__.py
#  - engine\ecs\commands.py
#  - engine\ecs\system.py
#  - engine\ecs\view.py
#  - engine\ecs\world.py
#  - engine\events\__init__.py
#  - engine\events\bus.py
#  - engine\game\__init__.py
#  - engine\resources\__init__.py
#  - engine\resources\store.py
#  - engine\scheduling\__init__.py
#  - engine\scheduling\scheduler.py
#  - engine\tests\__init__.py
#  - engine\tests\test_data_jsonio.py
#  - engine\tests\test_engine_smoke.py
#  - engine\tests\test_fish_fsm.py
#  - engine\tests\test_game_movement.py
#  - engine\tests\test_game_rect_render.py
#  - engine\tests\test_tank_movement_bounds.py
#  - engine\tests\test_tank_population_rules.py
#  - engine\adapters\pygame_render\__init__.py
#  - engine\adapters\pygame_render\app.py
#  - engine\adapters\pygame_render\renderer.py
#  - engine\adapters\pygame_render\systems.py
#  - engine\game\components\__init__.py
#  - engine\game\components\brain.py
#  - engine\game\components\fish.py
#  - engine\game\components\in_tank.py
#  - engine\game\components\movement_intent.py
#  - engine\game\components\position.py
#  - engine\game\components\rect_sprite.py
#  - engine\game\components\tank.py
#  - engine\game\components\tank_bounds.py
#  - engine\game\components\velocity.py
#  - engine\game\data\__init__.py
#  - engine\game\data\jsonio.py
#  - engine\game\data\species.json
#  - engine\game\data\tanks.json
#  - engine\game\factories\__init__.py
#  - engine\game\factories\fish_factory.py
#  - engine\game\factories\tank_factory.py
#  - engine\game\fsm\__init__.py
#  - engine\game\fsm\base_state.py
#  - engine\game\fsm\cruise_state.py
#  - engine\game\fsm\idle_state.py
#  - engine\game\rules\__init__.py
#  - engine\game\rules\population.py
#  - engine\game\systems\__init__.py
#  - engine\game\systems\fish_fsm_system.py
#  - engine\game\systems\movement_system.py
#  - engine\game\systems\rect_render_system.py
# === FILE START: export_script.py ===
```python
# export_script.py
import os
import re
PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
OUTPUT_FILE = os.path.join(PROJECT_ROOT, "project_export.txt")
# Ignore list
IGNORE_DIRS = {
    "venv", ".venv",
    "__pycache__", ".git", ".idea",
    ".mypy_cache", ".pytest_cache",
    "build", "dist"
}
# Add new non-Python extensions here
EXPORT_EXTENSIONS = {".py", ".json"}
VERSION_TAG = "PROJECT_EXPORT_v1.4"
# Optional clipboard support
try:
    import pyperclip  # noqa: F401
    _HAS_PYPERCLIP = True
except Exception:
    _HAS_PYPERCLIP = False
def is_ignored_dir(dirname: str) -> bool:
    return dirname.lower() in IGNORE_DIRS
def collect_files(root: str):
    """Collect python + json files."""
    collected = []
    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = [d for d in dirnames if not is_ignored_dir(d)]
        for filename in filenames:
            ext = os.path.splitext(filename)[1].lower()
            if ext in EXPORT_EXTENSIONS:
                full = os.path.join(dirpath, filename)
                rel = os.path.relpath(full, root)
                collected.append((rel, full))
    # deterministic ordering
    collected.sort(key=lambda x: (x[0].count(os.sep), x[0]))
    return collected
def compress_blank_lines(text: str) -> str:
    """Remove 2+ consecutive blank lines, reduce to max 1."""
    return re.sub(r"\n{2,}", "\n", text)
def build_table_of_contents(files):
    lines = [
        f"# === PROJECT TABLE OF CONTENTS ({len(files)} files) ===",
        f"# Version: {VERSION_TAG}",
        ""
    ]
    for path, _ in files:
        lines.append(f"#  - {path}")
    lines.append("")
    return "\n".join(lines)
def build_file_section(rel_path: str, full_path: str) -> str:
    """Read a file and wrap it."""
    try:
        with open(full_path, "r", encoding="utf-8") as f:
            code = f.read()
    except UnicodeDecodeError:
        code = "<Error reading file: non-UTF8 encoding>"
    code = compress_blank_lines(code)
    ext = os.path.splitext(rel_path)[1].lower()
    fence = "python" if ext == ".py" else "json" if ext == ".json" else ""
    return (
        f"# === FILE START: {rel_path} ===\n"
        f"```{fence}\n{code}\n```\n"
        f"# === FILE END: {rel_path} ===\n"
    )
def main():
    files = collect_files(PROJECT_ROOT)
    if not files:
        print("No files found.")
        return
    toc = build_table_of_contents(files)
    sections = [toc]
    for rel_path, full_path in files:
        sections.append(build_file_section(rel_path, full_path))
    final_text = "\n\n".join(sections)
    final_text = compress_blank_lines(final_text)
    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        out.write(final_text)
    # Clipboard copy happens *after* final_text exists, and only if available.
    if _HAS_PYPERCLIP:
        try:
            import pyperclip
            pyperclip.copy(final_text)
            print(f"Copied to clipboard ✓ ({VERSION_TAG})")
        except Exception as exc:
            print(f"⚠ Failed to copy to clipboard: {exc}")
    else:
        print("⚠ pyperclip not available; skipped clipboard copy.")
    size_kb = os.path.getsize(OUTPUT_FILE) / 1024
    print(f"Export complete: {len(files)} files, {size_kb:.1f} KB")
    print(f"Written to {OUTPUT_FILE}")
if __name__ == "__main__":
    main()
```
# === FILE END: export_script.py ===
# === FILE START: engine\__init__.py ===
```python
# engine/__init__.py
"""
Engine layer root package.
Contains reusable ECS, scheduling, events, resources, etc.
Knows nothing about fish, tanks, or Pygame.
"""
```
# === FILE END: engine\__init__.py ===
# === FILE START: engine\adapters\__init__.py ===
```python
# adapters/__init__.py
"""
Framework / IO integration layer.
Contains Pygame adapters for rendering, input, audio, etc.
"""
```
# === FILE END: engine\adapters\__init__.py ===
# === FILE START: engine\app\__init__.py ===
```python
# app/__init__.py
"""
Application / composition layer.
Wires together engine, game, and adapters.
"""
```
# === FILE END: engine\app\__init__.py ===
# === FILE START: engine\app\boot.py ===
```python
# engine/app/boot.py
from __future__ import annotations
from dataclasses import dataclass
import random
from engine.ecs import World
from engine.scheduling import Scheduler
from engine.resources import ResourceStore
from engine.events import EventBus
from engine.game.systems import MovementSystem, RectRenderSystem, FishFSMSystem
from engine.game.factories import (
    load_species_config,
    create_fish,      # still exported; handy later
    create_tank,
    load_tank_config,
)
from engine.game.rules import spawn_fish_in_tank_if_allowed
from engine.game.components.tank_bounds import TankBounds
@dataclass
class Engine:
    """
    Simple facade wrapping world + scheduler + resources.
    PygameApp will call engine.update(...) and engine.render(...).
    """
    world: World
    scheduler: Scheduler
    resources: ResourceStore
    def update(self, dt: float) -> None:
        self.scheduler.update(self.world, dt)
    def render(self, dt: float) -> None:
        self.scheduler.render(self.world, dt)
def _populate_debug_fish(world: World, species_cfg, tank_eid, tank_def, rng: random.Random) -> None:
    """
    Spawn a few test fish based on species.json so we can see something on screen.
    All fish are assigned to the given tank entity and respect its max_fish.
    Magic numbers (count, margin) and bounds all come from data:
    - tank_def["debug_spawn"]["count"]
    - tank_def["debug_spawn"]["margin"]
    - TankBounds of the tank entity
    """
    debug_cfg = tank_def.get("debug_spawn", {})
    count = int(debug_cfg.get("count", 8))
    margin = float(debug_cfg.get("margin", 50.0))
    # Get the tank's screen rect from its TankBounds component
    bounds_store = world.get_components(TankBounds)
    bounds = bounds_store.get(tank_eid)
    if bounds is not None:
        left = float(bounds.x)
        top = float(bounds.y)
        right = float(bounds.x + bounds.width)
        bottom = float(bounds.y + bounds.height)
    else:
        # Fallback if something went wrong; shouldn't normally happen.
        left, top, right, bottom = 0.0, 0.0, 1280.0, 720.0
    # Spawn within the tank rect, keeping a configurable margin from edges.
    for _ in range(count):
        x = rng.uniform(left + margin, right - margin)
        y = rng.uniform(top + margin, bottom - margin)
        spawn_fish_in_tank_if_allowed(
            world,
            tank_eid=tank_eid,
            species_cfg=species_cfg,
            species_id="debug_fish",
            x=x,
            y=y,
            rng=rng,
        )
def build_engine() -> Engine:
    """
    Composition root for the core engine.
    - Creates ResourceStore + EventBus.
    - Creates deterministic RNGs.
    - Loads species + tank config from data files.
    - Creates World + Scheduler and registers systems.
    - Spawns a few bouncing fish rectangles per config.
    """
    resources = ResourceStore()
    # Global event bus resource (will be used later by game & adapters)
    events = EventBus()
    resources.register("events", events)
    # Deterministic RNG hierarchy
    rng_root = random.Random(42)
    resources.set("rng_root", rng_root)
    resources.set("rng_ai", random.Random(rng_root.randint(0, 2**31 - 1)))
    resources.set("rng_spawns", random.Random(rng_root.randint(0, 2**31 - 1)))
    # Load configs
    species_cfg = load_species_config()
    resources.set("species_config", species_cfg)
    tank_cfg = load_tank_config()
    resources.set("tank_config", tank_cfg)
    # World + scheduler
    world = World()
    scheduler = Scheduler()
    # Install game systems
    fsm_sys = FishFSMSystem(resources)
    move_sys = MovementSystem(resources)
    render_sys = RectRenderSystem(resources)
    # Order matters: FSM should run before MovementSystem in the logic phase.
    scheduler.add_system(fsm_sys, phase="logic")
    scheduler.add_system(move_sys, phase="logic")
    scheduler.add_system(render_sys, phase="render")
    # For now we just create a single tank "tank_1"
    tank_def = tank_cfg["tanks"]["tank_1"]
    bounds = tank_def["bounds"]
    x, y, width, height = (
        float(bounds[0]),
        float(bounds[1]),
        float(bounds[2]),
        float(bounds[3]),
    )
    tank_eid = create_tank(
        world,
        tank_id="tank_1",
        max_fish=int(tank_def["max_fish"]),
        x=x,
        y=y,
        width=width,
        height=height,
    )
    # Debug entities so we see something
    rng_spawns: random.Random = resources.get("rng_spawns")
    _populate_debug_fish(world, species_cfg, tank_eid, tank_def, rng_spawns)
    return Engine(world=world, scheduler=scheduler, resources=resources)
```
# === FILE END: engine\app\boot.py ===
# === FILE START: engine\app\main.py ===
```python
# engine/app/main.py
from __future__ import annotations
from engine.app.boot import build_engine
from engine.adapters.pygame_render.app import PygameApp
def main() -> None:
    engine = build_engine()
    app = PygameApp(engine, width=1280, height=720, title="FishSim3 MVP")
    app.run()
if __name__ == "__main__":
    main()
```
# === FILE END: engine\app\main.py ===
# === FILE START: engine\ecs\__init__.py ===
```python
# engine/ecs/__init__.py
from .world import World, EntityId
from .system import System
from .view import View
__all__ = ["World", "EntityId", "System", "View"]
```
# === FILE END: engine\ecs\__init__.py ===
# === FILE START: engine\ecs\commands.py ===
```python
# engine/ecs/commands.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Iterable, Any
from .world import EntityId
@dataclass
class CreateEntityCmd:
    components: Iterable[Any]
@dataclass
class DestroyEntityCmd:
    entity: EntityId
```
# === FILE END: engine\ecs\commands.py ===
# === FILE START: engine\ecs\system.py ===
```python
# engine/ecs/system.py
from __future__ import annotations
from typing import Any, Dict, Set
class System:
    """
    Base class for all systems.
    - Each system belongs to a phase (pre_update / logic / post_update / render).
    - Systems receive a resources object (ResourceStore or similar).
    """
    # Default phase; subclasses should override.
    phase: str = "logic"
    def __init__(self, resources: Any) -> None:
        self.resources = resources
    def declare_requirements(self) -> Dict[str, Set[Any]]:
        """
        Optional: describe which components/resources this system needs.
        Not used by the MVP scheduler, but useful later for diagnostics,
        tooling, or automatic ordering.
        """
        return {}
    def update(self, world, dt: float) -> None:
        """Perform one frame of work."""
        raise NotImplementedError("System.update must be implemented by subclasses")
```
# === FILE END: engine\ecs\system.py ===
# === FILE START: engine\ecs\view.py ===
```python
# engine/ecs/view.py
from __future__ import annotations
from typing import Iterable, Tuple, Type, Any, Iterator
from .world import World, EntityId
class View:
    """
    Iterable *and* iterator over entities that have a given set of component types.
    Example:
        for eid, pos, vel in world.view(Position, Velocity):
            ...
        eid, pos = next(world.view(Position))
    """
    def __init__(self, world: World, component_types: Iterable[Type[Any]]) -> None:
        self._world = world
        self._component_types: Tuple[Type[Any], ...] = tuple(component_types)
        self._gen: Iterator[Any] | None = None  # underlying iterator for this pass
    # ------------------------------------------------------------------
    # Iterator protocol
    # ------------------------------------------------------------------
    def __iter__(self) -> "View":
        """
        Called when you do: for ... in view
        Resets the internal generator for a fresh iteration.
        """
        self._gen = self._iter_impl()
        return self
    def __next__(self):
        """
        Called when you do: next(view)
        If no generator yet (e.g. user called next(view) without iter(view)),
        create one on the fly.
        """
        if self._gen is None:
            self._gen = self._iter_impl()
        return next(self._gen)
    # ------------------------------------------------------------------
    # Internal iterator builder
    # ------------------------------------------------------------------
    def _iter_impl(self) -> Iterator[Any]:
        """
        Build a fresh iterator over (eid, comp1, comp2, ...).
        We compute the intersection of entity ids that have all components.
        """
        if not self._component_types:
            # No components requested: empty iterator
            return iter(())
        world = self._world
        first_type, *rest_types = self._component_types
        # We capture base_store here; it's fine if world mutates later,
        # because a new iteration will build a new generator.
        base_store = world.get_components(first_type)
        def generator() -> Iterator[Any]:
            for eid, first_comp in base_store.items():
                comps = [first_comp]
                missing = False
                for ctype in rest_types:
                    store = world.get_components(ctype)
                    comp = store.get(eid)
                    if comp is None:
                        missing = True
                        break
                    comps.append(comp)
                if not missing:
                    # (eid, c1, c2, ...)
                    yield (EntityId(eid), *comps)
        return generator()
```
# === FILE END: engine\ecs\view.py ===
# === FILE START: engine\ecs\world.py ===
```python
# engine/ecs/world.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, Type, TypeVar, Iterable, Tuple, List, Any
class EntityId(int):
    """Opaque identifier for an entity in the world."""
    pass
TComponent = TypeVar("TComponent")
@dataclass
class CreateEntityCmd:
    components: Iterable[Any]  # list[Component] really, but generic here
@dataclass
class DestroyEntityCmd:
    entity: EntityId
class World:
    """
    Minimal ECS World:
    - Generates entity IDs
    - Stores components grouped by type
    - Provides basic views over entities with given component sets
    - Has a simple command queue for create/destroy operations
    """
    def __init__(self) -> None:
        self._next_id: int = 1
        # {ComponentType: {EntityId: component_instance}}
        self._components: Dict[Type[Any], Dict[EntityId, Any]] = {}
        # Cache for views by component type tuple
        # (string annotation to avoid importing View at module import time)
        self._views: Dict[Tuple[Type[Any], ...], "View"] = {}
        # Deferred commands like CreateEntityCmd / DestroyEntityCmd
        self._command_queue: List[Any] = []
    # ------------------------------------------------------------------
    # Entity management
    # ------------------------------------------------------------------
    def create_entity(self) -> EntityId:
        eid = EntityId(self._next_id)
        self._next_id += 1
        return eid
    def destroy_entity(self, eid: EntityId) -> None:
        """Remove the entity from all component stores."""
        for comp_dict in self._components.values():
            comp_dict.pop(eid, None)
    # ------------------------------------------------------------------
    # Component management
    # ------------------------------------------------------------------
    def add_component(self, eid: EntityId, component: Any) -> None:
        ctype = type(component)
        store = self._components.setdefault(ctype, {})
        store[eid] = component
        self._invalidate_views_involving(ctype)
    def remove_component(self, eid: EntityId, component_type: Type[Any]) -> None:
        store = self._components.get(component_type)
        if store is not None and eid in store:
            del store[eid]
            self._invalidate_views_involving(component_type)
    def get_components(self, component_type: Type[TComponent]) -> Dict[EntityId, TComponent]:
        """Direct access to the raw dict for a single component type."""
        return self._components.setdefault(component_type, {})
    # ------------------------------------------------------------------
    # Views
    # ------------------------------------------------------------------
    def view(self, *component_types: Type[Any]) -> "View":
        """
        Return a View over all entities that have *all* the given components.
        Usage:
            for eid, pos, vel in world.view(Position, Velocity):
                ...
        """
        # LOCAL import to avoid circular import at module load time
        from .view import View
        key = tuple(component_types)
        view = self._views.get(key)
        if view is None:
            view = View(self, component_types)
            self._views[key] = view
        return view
    def _invalidate_views_involving(self, component_type: Type[Any]) -> None:
        """Drop cached views that depend on the given component type."""
        to_delete = [
            key for key in self._views.keys()
            if component_type in key
        ]
        for key in to_delete:
            del self._views[key]
    # ------------------------------------------------------------------
    # Commands
    # ------------------------------------------------------------------
    def queue_command(self, cmd: Any) -> None:
        """
        Queue a command to be applied later.
        Typical commands: CreateEntityCmd, DestroyEntityCmd.
        """
        self._command_queue.append(cmd)
    def flush_commands(self) -> None:
        """
        Apply all queued commands. Should be called by the scheduler
        in a predictable phase (e.g. 'post_update').
        """
        while self._command_queue:
            cmd = self._command_queue.pop(0)
            if isinstance(cmd, CreateEntityCmd):
                self._apply_create_entity(cmd)
            elif isinstance(cmd, DestroyEntityCmd):
                self.destroy_entity(cmd.entity)
            else:
                raise TypeError(f"Unknown command type: {type(cmd)!r}")
    def _apply_create_entity(self, cmd: CreateEntityCmd) -> EntityId:
        eid = self.create_entity()
        for component in cmd.components:
            self.add_component(eid, component)
        return eid
```
# === FILE END: engine\ecs\world.py ===
# === FILE START: engine\events\__init__.py ===
```python
# engine/events/__init__.py
from .bus import EventBus
__all__ = ["EventBus"]
```
# === FILE END: engine\events\__init__.py ===
# === FILE START: engine\events\bus.py ===
```python
# engine/events/bus.py
from __future__ import annotations
from typing import Callable, Dict, List, Type, Any
class EventBus:
    """
    Simple synchronous pub-sub event bus.
    Systems or adapters can:
      - subscribe(event_type, callback)
      - publish(event_instance)
    """
    def __init__(self) -> None:
        # {event_type: [callback]}
        self._subs: Dict[Type[Any], List[Callable[[Any], None]]] = {}
    def subscribe(self, event_type: Type[Any], callback: Callable[[Any], None]) -> None:
        self._subs.setdefault(event_type, []).append(callback)
    def publish(self, event: Any) -> None:
        callbacks = self._subs.get(type(event), [])
        for cb in callbacks:
            cb(event)
```
# === FILE END: engine\events\bus.py ===
# === FILE START: engine\game\__init__.py ===
```python
# engine/game/__init__.py
"""
Game (domain) layer.
"""
```
# === FILE END: engine\game\__init__.py ===
# === FILE START: engine\resources\__init__.py ===
```python
# engine/resources/__init__.py
from .store import ResourceStore
__all__ = ["ResourceStore"]
```
# === FILE END: engine\resources\__init__.py ===
# === FILE START: engine\resources\store.py ===
```python
# engine/resources/store.py
from __future__ import annotations
from typing import Any, Dict
class ResourceStore:
    """
    Simple registry for globally accessible singletons:
      - config
      - rng
      - assets
      - audio
      - time
      - screen info
      - event bus, etc.
    """
    def __init__(self) -> None:
        self._items: Dict[str, Any] = {}
    def register(self, key: str, value: Any) -> None:
        if key in self._items:
            raise KeyError(f"Resource {key!r} is already registered")
        self._items[key] = value
    def set(self, key: str, value: Any) -> None:
        """Replace or create a resource without complaining."""
        self._items[key] = value
    def get(self, key: str) -> Any:
        return self._items[key]
    def try_get(self, key: str, default: Any = None) -> Any:
        return self._items.get(key, default)
```
# === FILE END: engine\resources\store.py ===
# === FILE START: engine\scheduling\__init__.py ===
```python
# engine/scheduling/__init__.py
from .scheduler import Scheduler
__all__ = ["Scheduler"]
```
# === FILE END: engine\scheduling\__init__.py ===
# === FILE START: engine\scheduling\scheduler.py ===
```python
# engine/scheduling/scheduler.py
from __future__ import annotations
from typing import Dict, List
from engine.ecs import System, World
class Scheduler:
    """
    Very simple phase-based scheduler.
    Phases:
      - pre_update: input, time step updates, housekeeping
      - logic: gameplay, AI, physics
      - post_update: apply queued commands, cleanup, sync
      - render: draw the current state
    """
    def __init__(self) -> None:
        self._systems_by_phase: Dict[str, List[System]] = {
            "pre_update": [],
            "logic": [],
            "post_update": [],
            "render": [],
        }
    def add_system(self, system: System, phase: str | None = None) -> None:
        """
        Register a system for a given phase.
        If phase is None, system.phase is used.
        """
        ph = phase or getattr(system, "phase", "logic")
        if ph not in self._systems_by_phase:
            raise ValueError(f"Unknown phase: {ph!r}")
        self._systems_by_phase[ph].append(system)
    # ------------------------------------------------------------------
    # Update & render loops
    # ------------------------------------------------------------------
    def update(self, world: World, dt: float) -> None:
        # pre_update, logic, post_update
        for phase in ("pre_update", "logic", "post_update"):
            for sys in self._systems_by_phase[phase]:
                sys.update(world, dt)
            # After post_update, we want to apply entity commands
            if phase == "post_update":
                world.flush_commands()
    def render(self, world: World, dt: float) -> None:
        for sys in self._systems_by_phase["render"]:
            sys.update(world, dt)
```
# === FILE END: engine\scheduling\scheduler.py ===
# === FILE START: engine\tests\__init__.py ===
```python
```
# === FILE END: engine\tests\__init__.py ===
# === FILE START: engine\tests\test_data_jsonio.py ===
```python
# engine/tests/test_data_jsonio.py
from __future__ import annotations
from pathlib import Path
from engine.game.data.jsonio import data_path, load_json
from engine.game.factories import load_species_config
from engine.game.factories.tank_factory import load_tank_config
def test_data_path_points_to_data_dir() -> None:
    """
    data_path('species.json') should return a Path pointing to an existing file
    inside the game data folder.
    """
    p = data_path("species.json")
    assert isinstance(p, Path)
    assert p.name == "species.json"
    assert p.exists(), "species.json should exist in engine/game/data"
def test_load_json_reads_species_file() -> None:
    """
    load_json('species.json') should return a dict with '_version' and 'species' keys.
    """
    raw = load_json("species.json")
    assert isinstance(raw, dict)
    assert "_version" in raw
    assert "species" in raw
    assert isinstance(raw["species"], dict)
def test_load_species_config_returns_species_map() -> None:
    """
    load_species_config should return the 'species' dict from species.json
    and contain 'debug_fish' with basic fields.
    """
    species_cfg = load_species_config()
    assert isinstance(species_cfg, dict)
    assert "debug_fish" in species_cfg
    debug = species_cfg["debug_fish"]
    assert "width" in debug
    assert "height" in debug
    assert "color" in debug
    assert "speed_range" in debug
def test_load_tank_config_reads_tanks_json() -> None:
    """
    load_tank_config should read tanks.json and expose its structure,
    including 'tank_1' with max_fish and bounds.
    """
    cfg = load_tank_config()
    assert isinstance(cfg, dict)
    assert "_version" in cfg
    assert "tanks" in cfg
    tanks = cfg["tanks"]
    assert isinstance(tanks, dict)
    assert "tank_1" in tanks
    tank1 = tanks["tank_1"]
    assert "max_fish" in tank1
    assert "bounds" in tank1
    bounds = tank1["bounds"]
    assert isinstance(bounds, list)
    assert len(bounds) == 4
```
# === FILE END: engine\tests\test_data_jsonio.py ===
# === FILE START: engine\tests\test_engine_smoke.py ===
```python
# tests/test_engine_smoke.py
from __future__ import annotations
from dataclasses import dataclass
from engine.ecs import World, System
from engine.scheduling import Scheduler
from engine.resources import ResourceStore
from engine.events import EventBus
# ----------------------------------------------------------------------
# Fake components for this test
# ----------------------------------------------------------------------
@dataclass
class Position:
    x: float
    y: float
@dataclass
class Velocity:
    x: float
    y: float
# ----------------------------------------------------------------------
# Example systems
# ----------------------------------------------------------------------
class MovementSystem(System):
    phase = "logic"
    def update(self, world: World, dt: float) -> None:
        for eid, pos, vel in world.view(Position, Velocity):
            pos.x += vel.x * dt
            pos.y += vel.y * dt
class EventCountingSystem(System):
    phase = "pre_update"
    def __init__(self, resources: ResourceStore) -> None:
        super().__init__(resources)
        self.count = 0
        bus: EventBus = resources.get("events")
        bus.subscribe(MyEvent, self.on_event)
    def on_event(self, event: "MyEvent") -> None:
        self.count += 1
    def update(self, world: World, dt: float) -> None:
        # This system just counts events via the callback.
        pass
# Simple event for the EventBus test
@dataclass
class MyEvent:
    value: int
def test_engine_smoke() -> None:
    # Resources
    resources = ResourceStore()
    bus = EventBus()
    resources.register("events", bus)
    # World
    world = World()
    eid = world.create_entity()
    world.add_component(eid, Position(0.0, 0.0))
    world.add_component(eid, Velocity(10.0, 0.0))
    # Systems + scheduler
    scheduler = Scheduler()
    move_sys = MovementSystem(resources)
    evt_sys = EventCountingSystem(resources)
    scheduler.add_system(evt_sys)
    scheduler.add_system(move_sys)
    # Publish some events
    bus.publish(MyEvent(1))
    bus.publish(MyEvent(2))
    # Run one frame (dt = 1.0)
    scheduler.update(world, dt=1.0)
    # Assert movement happened
    (only_eid, pos) = next(world.view(Position))
    assert only_eid == eid
    assert pos.x == 10.0
    assert pos.y == 0.0
    # Assert that events were counted via EventBus
    assert evt_sys.count == 2
```
# === FILE END: engine\tests\test_engine_smoke.py ===
# === FILE START: engine\tests\test_fish_fsm.py ===
```python
# engine/tests/test_fish_fsm.py
from __future__ import annotations
import math
import random
from engine.ecs import World
from engine.resources import ResourceStore
from engine.game.components import Fish, Brain, MovementIntent
from engine.game.systems import FishFSMSystem
def _make_world_and_fsm() -> tuple[World, ResourceStore, FishFSMSystem]:
    """
    Helper: create a World + ResourceStore + FishFSMSystem
    with a deterministic rng_ai.
    """
    world = World()
    resources = ResourceStore()
    # Deterministic RNG for FSM decisions
    rng_ai = random.Random(123)
    resources.set("rng_ai", rng_ai)
    fsm_sys = FishFSMSystem(resources)
    return world, resources, fsm_sys
def test_fish_fsm_idle_to_cruise_to_idle() -> None:
    """
    A fish should:
      - start in 'idle' with zero intent
      - after IDLE_DURATION, switch to 'cruise' with non-zero intent
      - after CRUISE_DURATION, switch back to 'idle' with zero intent again
    """
    world, resources, fsm_sys = _make_world_and_fsm()
    eid = world.create_entity()
    world.add_component(eid, Fish(species_id="debug_fish"))
    brain = Brain()
    intent = MovementIntent()
    world.add_component(eid, brain)
    world.add_component(eid, intent)
    # Before any update
    assert brain.state == "idle"
    assert brain.initialized is False
    assert intent.target_vx == 0.0
    assert intent.target_vy == 0.0
    # After exactly one idle duration: should have transitioned to cruise
    fsm_sys.update(world, dt=FishFSMSystem.IDLE_DURATION)
    assert brain.state == "cruise"
    assert brain.initialized is True
    # Entering cruise resets time_in_state
    assert brain.time_in_state == 0.0
    # Cruise should have non-zero intent
    assert (intent.target_vx != 0.0) or (intent.target_vy != 0.0)
    # After cruise duration: should be back in idle with zero intent
    fsm_sys.update(world, dt=FishFSMSystem.CRUISE_DURATION)
    assert brain.state == "idle"
    assert intent.target_vx == 0.0
    assert intent.target_vy == 0.0
def test_multiple_fish_share_fsm_but_have_independent_brains() -> None:
    """
    Two fish with brains should both be updated by the FSM system and keep
    their own state / timers.
    """
    world, resources, fsm_sys = _make_world_and_fsm()
    e1 = world.create_entity()
    e2 = world.create_entity()
    world.add_component(e1, Fish(species_id="debug_fish"))
    world.add_component(e2, Fish(species_id="debug_fish"))
    b1 = Brain()
    b2 = Brain()
    i1 = MovementIntent()
    i2 = MovementIntent()
    world.add_component(e1, b1)
    world.add_component(e1, i1)
    world.add_component(e2, b2)
    world.add_component(e2, i2)
    # Run one idle duration (both should leave idle → cruise)
    fsm_sys.update(world, dt=FishFSMSystem.IDLE_DURATION)
    assert b1.state == "cruise"
    assert b2.state == "cruise"
    # Intent should be non-zero for both (but not necessarily equal)
    assert (i1.target_vx != 0.0) or (i1.target_vy != 0.0)
    assert (i2.target_vx != 0.0) or (i2.target_vy != 0.0)
    # Advance cruise and ensure both go back to idle separately
    fsm_sys.update(world, dt=FishFSMSystem.CRUISE_DURATION)
    assert b1.state == "idle"
    assert b2.state == "idle"
    assert i1.target_vx == 0.0 and i1.target_vy == 0.0
    assert i2.target_vx == 0.0 and i2.target_vy == 0.0
def test_cruise_uses_species_speed_range() -> None:
    """
    CruiseState should respect species_config['speed_range'] when present.
    We:
      - provide a custom species_config with a tight [min, max] range
      - let the FSM transition idle → cruise
      - measure the resulting MovementIntent speed
      - assert it falls within the configured range
    """
    world = World()
    resources = ResourceStore()
    # Deterministic RNG for reproducible direction/speed
    rng_ai = random.Random(999)
    resources.set("rng_ai", rng_ai)
    # Custom species config with a narrow speed range
    speed_min = 10.0
    speed_max = 15.0
    species_cfg = {
        "debug_fish": {
            "speed_range": [speed_min, speed_max],
        }
    }
    resources.set("species_config", species_cfg)
    fsm_sys = FishFSMSystem(resources)
    eid = world.create_entity()
    world.add_component(eid, Fish(species_id="debug_fish"))
    brain = Brain()
    intent = MovementIntent()
    world.add_component(eid, brain)
    world.add_component(eid, intent)
    # Trigger first transition: idle → cruise
    fsm_sys.update(world, dt=FishFSMSystem.IDLE_DURATION)
    assert brain.state == "cruise"
    # Compute resulting speed from intent vector
    speed = math.hypot(intent.target_vx, intent.target_vy)
    assert speed_min <= speed <= speed_max
```
# === FILE END: engine\tests\test_fish_fsm.py ===
# === FILE START: engine\tests\test_game_movement.py ===
```python
from __future__ import annotations
from engine.ecs import World
from engine.resources import ResourceStore
from engine.game.components import Position, Velocity, RectSprite
from engine.game.systems import MovementSystem
def make_world_and_system(screen_size=(800, 600)):
    """Helper: world with one movement system + resources."""
    world = World()
    resources = ResourceStore()
    # In the new model, logical space drives movement.
    resources.set("logical_size", screen_size)
    # screen_size is still useful for rendering, so we keep it too.
    resources.set("screen_size", screen_size)
    move_sys = MovementSystem(resources)
    return world, resources, move_sys
def test_movement_integrates_position() -> None:
    """
    Given an entity with Position + Velocity + RectSprite,
    MovementSystem should integrate position as pos += v * dt
    and then apply boundary checks (including possible bounce).
    """
    world, resources, move_sys = make_world_and_system(screen_size=(800, 600))
    eid = world.create_entity()
    pos = Position(x=10.0, y=20.0)
    vel = Velocity(vx=100.0, vy=-50.0)
    sprite = RectSprite(width=50.0, height=30.0, color=(255, 0, 0))
    world.add_component(eid, pos)
    world.add_component(eid, vel)
    world.add_component(eid, sprite)
    # Run one update with dt = 0.5 seconds
    move_sys.update(world, dt=0.5)
    # Fetch components directly from the stores
    pos_store = world.get_components(Position)
    vel_store = world.get_components(Velocity)
    # There should be exactly one entity
    assert len(pos_store) == 1
    assert len(vel_store) == 1
    (only_eid, new_pos) = next(iter(pos_store.items()))
    new_vel = vel_store[only_eid]
    assert only_eid == eid
    # X: integrated only (no horizontal bounce in this setup)
    # 10 + 100 * 0.5 = 60
    assert new_pos.x == 60.0
    # Y: would be 20 + (-50 * 0.5) = -5,
    # but we hit the top border, so it gets clamped to 0 and vy is flipped
    assert new_pos.y == 0.0
    assert new_vel.vy == 50.0
    # vx should be unchanged
    assert new_vel.vx == 100.0
def test_movement_bounces_on_right_edge() -> None:
    """
    If a rectangle moves beyond the right edge, it should be clamped inside
    and its vx should be flipped.
    """
    screen_w, screen_h = 400, 300
    world, resources, move_sys = make_world_and_system(screen_size=(screen_w, screen_h))
    eid = world.create_entity()
    sprite = RectSprite(width=50.0, height=30.0, color=(0, 255, 0))
    # Start close to the right edge, moving right
    pos = Position(x=screen_w - sprite.width - 5.0, y=100.0)
    vel = Velocity(vx=100.0, vy=0.0)
    world.add_component(eid, pos)
    world.add_component(eid, vel)
    world.add_component(eid, sprite)
    # dt big enough to cross the boundary
    move_sys.update(world, dt=0.2)
    pos_store = world.get_components(Position)
    vel_store = world.get_components(Velocity)
    assert len(pos_store) == 1
    assert len(vel_store) == 1
    (only_eid, new_pos) = next(iter(pos_store.items()))
    new_vel = vel_store[only_eid]
    assert only_eid == eid
    # X should be clamped to screen_w - width
    assert new_pos.x == screen_w - sprite.width
    # Velocity should be flipped
    assert new_vel.vx == -100.0
```
# === FILE END: engine\tests\test_game_movement.py ===
# === FILE START: engine\tests\test_game_rect_render.py ===
```python
# engine/tests/test_game_rect_render.py
from __future__ import annotations
from engine.ecs import World
from engine.resources import ResourceStore
from engine.game.components import Position, RectSprite
from engine.game.systems import RectRenderSystem
class FakeRenderer:
    """
    Test double for the Renderer:
    - records calls to clear(), draw_rect(), present()
    - no pygame dependency
    """
    def __init__(self) -> None:
        self.cleared = False
        self.presented = False
        self.draw_calls = []  # list of (x, y, w, h, color, outline_width)
    def clear(self) -> None:
        self.cleared = True
    def present(self) -> None:
        self.presented = True
    def draw_rect(self, x, y, w, h, color, outline_width=0) -> None:
        self.draw_calls.append((x, y, w, h, color, outline_width))
def _make_world_and_render_system(
    logical_size=(800, 600),
    screen_size=(800, 600),
):
    """
    Helper: create World + ResourceStore + RectRenderSystem + FakeRenderer
    with given logical and screen sizes.
    """
    world = World()
    resources = ResourceStore()
    fake_renderer = FakeRenderer()
    resources.set("renderer", fake_renderer)
    resources.set("logical_size", logical_size)
    resources.set("screen_size", screen_size)
    render_sys = RectRenderSystem(resources)
    return world, resources, render_sys, fake_renderer
def test_rect_render_system_draws_rectangles_no_scaling() -> None:
    """
    When logical_size == screen_size, RectRenderSystem should:
      - clear the renderer
      - draw one rect per entity with Position + RectSprite
      - present the frame
      - pass coordinates through 1:1 (no scaling)
    """
    logical_size = (800, 600)
    screen_size = (800, 600)
    world, resources, render_sys, fake_renderer = _make_world_and_render_system(
        logical_size=logical_size,
        screen_size=screen_size,
    )
    # Create two entities with Position + RectSprite in logical space
    eid1 = world.create_entity()
    world.add_component(eid1, Position(x=10.0, y=20.0))
    world.add_component(
        eid1,
        RectSprite(width=30.0, height=40.0, color=(255, 0, 0)),
    )
    eid2 = world.create_entity()
    world.add_component(eid2, Position(x=100.0, y=50.0))
    world.add_component(
        eid2,
        RectSprite(width=60.0, height=20.0, color=(0, 255, 0)),
    )
    # Run render system once
    render_sys.update(world, dt=0.016)
    # Assert renderer was used as expected
    assert fake_renderer.cleared is True
    assert fake_renderer.presented is True
    assert len(fake_renderer.draw_calls) == 2
    calls = fake_renderer.draw_calls
    # Because scale_x == scale_y == 1, we expect coordinates unchanged
    assert any(
        c[0] == 10.0 and c[1] == 20.0 and c[2] == 30.0 and c[3] == 40.0 and c[4] == (255, 0, 0)
        for c in calls
    )
    assert any(
        c[0] == 100.0 and c[1] == 50.0 and c[2] == 60.0 and c[3] == 20.0 and c[4] == (0, 255, 0)
        for c in calls
    )
def test_rect_render_system_scales_logical_to_screen() -> None:
    """
    When screen_size != logical_size, RectRenderSystem should scale logical
    positions and sizes into screen space.
    Example:
      logical_size = (400, 300)
      screen_size  = (800, 600)
      => scale_x = scale_y = 2.0
    """
    logical_size = (400, 300)
    screen_size = (800, 600)
    world, resources, render_sys, fake_renderer = _make_world_and_render_system(
        logical_size=logical_size,
        screen_size=screen_size,
    )
    # One entity in logical space
    eid = world.create_entity()
    world.add_component(eid, Position(x=10.0, y=20.0))  # logical coords
    world.add_component(
        eid,
        RectSprite(width=30.0, height=40.0, color=(123, 111, 222)),
    )
    # With logical (400x300) → screen (800x600), scale = 2.0 both axes:
    #   x_px = 10 * 2 = 20
    #   y_px = 20 * 2 = 40
    #   w_px = 30 * 2 = 60
    #   h_px = 40 * 2 = 80
    render_sys.update(world, dt=0.016)
    assert fake_renderer.cleared is True
    assert fake_renderer.presented is True
    assert len(fake_renderer.draw_calls) == 1
    (x_px, y_px, w_px, h_px, color, outline_width) = fake_renderer.draw_calls[0]
    assert x_px == 20.0
    assert y_px == 40.0
    assert w_px == 60.0
    assert h_px == 80.0
    assert color == (123, 111, 222)
    assert outline_width == 0
```
# === FILE END: engine\tests\test_game_rect_render.py ===
# === FILE START: engine\tests\test_tank_movement_bounds.py ===
```python
# engine/tests/test_tank_movement_bounds.py
from __future__ import annotations
from engine.ecs import World
from engine.resources import ResourceStore
from engine.game.components import (
    Position,
    Velocity,
    RectSprite,
    Tank,
    TankBounds,
    InTank,
)
from engine.game.systems import MovementSystem
def _make_world_with_movement(screen_size=(800, 600)):
    world = World()
    resources = ResourceStore()
    resources.set("logical_size", screen_size)
    resources.set("screen_size", screen_size)
    move_sys = MovementSystem(resources)
    return world, resources, move_sys
def test_fish_in_tank_bounces_against_tank_bounds_not_screen() -> None:
    """
    TankBounds should restrict movement:
    - We create a tank smaller than the screen, put a fish near the right edge,
      and move it right.
    - It should bounce at the tank's right edge, even though the screen is bigger.
    """
    world, resources, move_sys = _make_world_with_movement(screen_size=(800, 600))
    # Define a small tank in the middle of the screen
    tank_eid = world.create_entity()
    world.add_component(tank_eid, Tank(tank_id="small_tank", max_fish=10))
    world.add_component(tank_eid, TankBounds(x=100.0, y=50.0, width=200.0, height=200.0))
    # Tank bounds => rect [100, 50] to [300, 250]
    # We'll put the fish near the right edge inside the tank.
    sprite = RectSprite(width=10.0, height=10.0, color=(255, 255, 255))
    # For the top-left of the sprite:
    #   min_x = 100
    #   max_x = 300 - 10 = 290
    start_x = 289.0  # 1 pixel left of max_x
    pos = Position(x=start_x, y=100.0)
    vel = Velocity(vx=50.0, vy=0.0)
    fish_eid = world.create_entity()
    world.add_component(fish_eid, pos)
    world.add_component(fish_eid, vel)
    world.add_component(fish_eid, sprite)
    world.add_component(fish_eid, InTank(tank=tank_eid))
    # dt=1.0 -> naive integration would put x at 339.0,
    # which is beyond the tank's right edge and also still within the screen.
    move_sys.update(world, dt=1.0)
    # After the update, we expect:
    # - x clamped to max_x (= 290)
    # - vx flipped to -50.0
    assert pos.x == 290.0
    assert vel.vx == -50.0
def test_fish_without_tank_uses_full_screen_bounds() -> None:
    """
    As a fallback, entities without InTank (or whose tank has no TankBounds)
    should still use full-screen bounds.
    This guards the 'fallback to screen' code path.
    """
    screen_w, screen_h = 400, 300
    world, resources, move_sys = _make_world_with_movement(screen_size=(screen_w, screen_h))
    sprite = RectSprite(width=20.0, height=20.0, color=(0, 255, 0))
    # Place near the right edge of the *screen* and move right.
    start_x = screen_w - sprite.width - 5.0  # 400 - 20 - 5 = 375
    pos = Position(x=start_x, y=100.0)
    vel = Velocity(vx=100.0, vy=0.0)
    eid = world.create_entity()
    world.add_component(eid, pos)
    world.add_component(eid, vel)
    world.add_component(eid, sprite)
    # Crucially: NO InTank component here.
    move_sys.update(world, dt=0.2)  # we cross the right edge
    # Same expectations as the existing movement test:
    assert pos.x == screen_w - sprite.width  # clamped to 380
    assert vel.vx == -100.0  # bounced
```
# === FILE END: engine\tests\test_tank_movement_bounds.py ===
# === FILE START: engine\tests\test_tank_population_rules.py ===
```python
# engine/tests/test_tank_population_rules.py
from __future__ import annotations
import random
from engine.ecs import World
from engine.game.components import Fish, InTank, Tank
from engine.game.factories import load_species_config
from engine.game.rules import (
    count_fish_in_tank,
    can_spawn_fish_in_tank,
    spawn_fish_in_tank_if_allowed,
)
def _add_fish_in_tank(world: World, tank_eid, species_id: str = "debug_fish") -> int:
    """
    Helper: add a bare Fish + InTank to the world without using create_fish.
    We don't care about position/velocity/sprite for population counting.
    """
    eid = world.create_entity()
    world.add_component(eid, Fish(species_id=species_id))
    world.add_component(eid, InTank(tank=tank_eid))
    return eid
def test_count_fish_in_tank_counts_only_that_tank() -> None:
    world = World()
    # Two tanks in the same world
    tank1 = world.create_entity()
    world.add_component(tank1, Tank(tank_id="tank_1", max_fish=10))
    tank2 = world.create_entity()
    world.add_component(tank2, Tank(tank_id="tank_2", max_fish=10))
    # Add 2 fish in tank1, 1 fish in tank2
    _add_fish_in_tank(world, tank1)
    _add_fish_in_tank(world, tank1)
    _add_fish_in_tank(world, tank2)
    assert count_fish_in_tank(world, tank1) == 2
    assert count_fish_in_tank(world, tank2) == 1
def test_can_spawn_fish_in_tank_respects_max_fish() -> None:
    world = World()
    tank = world.create_entity()
    world.add_component(tank, Tank(tank_id="cap_test", max_fish=2))
    # Initially empty -> OK
    assert can_spawn_fish_in_tank(world, tank) is True
    # Add 2 fish -> cap reached
    _add_fish_in_tank(world, tank)
    _add_fish_in_tank(world, tank)
    assert count_fish_in_tank(world, tank) == 2
    assert can_spawn_fish_in_tank(world, tank) is False
def test_can_spawn_fish_in_tank_no_tank_component_means_no_cap() -> None:
    world = World()
    # Create an entity but DO NOT add Tank() component
    pseudo_tank = world.create_entity()
    # Spec says: if no Tank component -> treat as "no limit"
    assert can_spawn_fish_in_tank(world, pseudo_tank) is True
def test_spawn_fish_in_tank_if_allowed_spawns_and_links_to_tank() -> None:
    """
    When under the cap, spawn_fish_in_tank_if_allowed should:
      - return a new entity id
      - add that fish to the requested tank (InTank.tank == tank_eid)
      - increase the population count for that tank
    """
    world = World()
    tank = world.create_entity()
    world.add_component(tank, Tank(tank_id="tank_spawn", max_fish=2))
    species_cfg = load_species_config()
    rng = random.Random(123)
    # First spawn -> allowed
    fish_eid = spawn_fish_in_tank_if_allowed(
        world,
        tank_eid=tank,
        species_cfg=species_cfg,
        species_id="debug_fish",
        x=100.0,
        y=100.0,
        rng=rng,
    )
    assert fish_eid is not None
    assert count_fish_in_tank(world, tank) == 1
    # Check that InTank points to the right tank
    in_tank_store = world.get_components(InTank)
    in_tank = in_tank_store[fish_eid]
    assert in_tank.tank == tank
def test_spawn_fish_in_tank_if_allowed_blocks_when_full() -> None:
    """
    Once the tank has reached max_fish, further spawns should return None
    and not increase the population count.
    """
    world = World()
    tank = world.create_entity()
    world.add_component(tank, Tank(tank_id="tank_full", max_fish=1))
    species_cfg = load_species_config()
    rng = random.Random(999)
    # First spawn -> allowed
    first = spawn_fish_in_tank_if_allowed(
        world,
        tank_eid=tank,
        species_cfg=species_cfg,
        species_id="debug_fish",
        x=50.0,
        y=50.0,
        rng=rng,
    )
    assert first is not None
    assert count_fish_in_tank(world, tank) == 1
    # Second spawn -> blocked
    second = spawn_fish_in_tank_if_allowed(
        world,
        tank_eid=tank,
        species_cfg=species_cfg,
        species_id="debug_fish",
        x=60.0,
        y=60.0,
        rng=rng,
    )
    assert second is None
    assert count_fish_in_tank(world, tank) == 1
```
# === FILE END: engine\tests\test_tank_population_rules.py ===
# === FILE START: engine\adapters\pygame_render\__init__.py ===
```python
# adapters/pygame_render/__init__.py
from .renderer import Renderer
from .app import PygameApp
__all__ = ["Renderer", "PygameApp"]
```
# === FILE END: engine\adapters\pygame_render\__init__.py ===
# === FILE START: engine\adapters\pygame_render\app.py ===
```python
# engine/adapters/pygame_render/app.py
from __future__ import annotations
import pygame
from engine.adapters.pygame_render.renderer import Renderer
class PygameApp:
    """
    Thin Pygame application wrapper.
    Responsibilities:
      - Initialize Pygame and create the window.
      - Attach a Renderer to the engine's ResourceStore.
      - Drive the main loop: poll events, call engine.update and engine.render.
      - Handle window resize and propagate new size to resources.
    """
    def __init__(
        self,
        engine,
        width: int = 1280,
        height: int = 720,
        title: str = "FishSim3",
    ) -> None:
        self.engine = engine
        self.width = width
        self.height = height
        self.title = title
        self._running = False
        # --- Pygame init & window creation ---
        pygame.init()
        # Make window resizable
        self.screen = pygame.display.set_mode(
            (self.width, self.height),
            pygame.RESIZABLE,
        )
        pygame.display.set_caption(self.title)
        self.clock = pygame.time.Clock()
        # --- Attach Renderer + screen info as resources ---
        renderer = Renderer(self.screen, bg_color=(30, 40, 90))
        self.engine.resources.set("renderer", renderer)
        self.engine.resources.set("screen_size", (self.width, self.height))
    def _handle_resize(self, event: pygame.event.Event) -> None:
        """Handle VIDEORESIZE: recreate window, update renderer + resources."""
        self.width, self.height = event.size
        # Recreate the display surface with RESIZABLE flag
        self.screen = pygame.display.set_mode(
            (self.width, self.height),
            pygame.RESIZABLE,
        )
        # Update renderer to draw to the new surface
        renderer: Renderer = self.engine.resources.get("renderer")
        renderer.screen = self.screen
        # Update screen_size resource so systems see the new size
        self.engine.resources.set("screen_size", (self.width, self.height))
    def run(self) -> None:
        """Main loop. ESC or window close will exit."""
        self._running = True
        while self._running:
            # Cap at ~60 FPS, get dt in seconds
            dt_ms = self.clock.tick(60)
            dt = dt_ms / 1000.0
            # --- Event polling ---
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self._running = False
                elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    self._running = False
                elif event.type == pygame.VIDEORESIZE:
                    # User resized the window
                    self._handle_resize(event)
            # --- Engine update & render ---
            self.engine.update(dt)
            self.engine.render(dt)
        pygame.quit()
```
# === FILE END: engine\adapters\pygame_render\app.py ===
# === FILE START: engine\adapters\pygame_render\renderer.py ===
```python
# engine/adapters/pygame_render/renderer.py
from __future__ import annotations
import pygame
class Renderer:
    """
    Thin wrapper around the Pygame screen surface.
    Systems will use this via the ResourceStore, not via raw pygame calls.
    """
    def __init__(self, screen: pygame.Surface, bg_color=(30, 40, 90)) -> None:
        self.screen = screen
        self.bg_color = bg_color
    def clear(self) -> None:
        """Fill the entire screen with the background color."""
        self.screen.fill(self.bg_color)
    def present(self) -> None:
        """Present the backbuffer to the display."""
        pygame.display.flip()
    def draw_rect(self, x: float, y: float,
                  width: float, height: float,
                  color, outline_width: int = 0) -> None:
        """
        Draw a rectangle given primitive values (no pygame.Rect in game layer).
        """
        rect = pygame.Rect(int(x), int(y), int(width), int(height))
        pygame.draw.rect(self.screen, color, rect, outline_width)
```
# === FILE END: engine\adapters\pygame_render\renderer.py ===
# === FILE START: engine\adapters\pygame_render\systems.py ===
```python
# adapters/pygame_render/systems.py
from __future__ import annotations
from engine.ecs import System, World
from engine.resources import ResourceStore
class ClearScreenSystem(System):
    """
    Render-phase system that clears the screen and presents it.
    For now this just gives us a visible background color so we can
    verify the PygameApp + engine loop is working.
    """
    phase = "render"
    def update(self, world: World, dt: float) -> None:
        resources: ResourceStore = self.resources  # type: ignore[assignment]
        renderer = resources.try_get("renderer")
        if renderer is None:
            # Renderer is not attached yet: nothing to do.
            return
        renderer.clear()
        renderer.present()
```
# === FILE END: engine\adapters\pygame_render\systems.py ===
# === FILE START: engine\game\components\__init__.py ===
```python
# engine/game/components/__init__.py
from .position import Position
from .velocity import Velocity
from .rect_sprite import RectSprite
from .fish import Fish
from .tank import Tank
from .in_tank import InTank
from .tank_bounds import TankBounds
from .brain import Brain
from .movement_intent import MovementIntent
__all__ = [
    "Position",
    "Velocity",
    "RectSprite",
    "Fish",
    "Tank",
    "InTank",
    "TankBounds",
    "Brain",
    "MovementIntent",
]
```
# === FILE END: engine\game\components\__init__.py ===
# === FILE START: engine\game\components\brain.py ===
```python
# engine/game/components/brain.py
from dataclasses import dataclass
@dataclass
class Brain:
    """
    FSM brain for a fish.
    Fields:
      - state: current state name ("idle", "cruise", ...)
      - time_in_state: seconds spent in current state
      - state_duration: planned duration of current state
      - initialized: whether on_enter has run at least once for the current state
    """
    state: str = "idle"
    time_in_state: float = 0.0
    state_duration: float = 0.0
    initialized: bool = False
```
# === FILE END: engine\game\components\brain.py ===
# === FILE START: engine\game\components\fish.py ===
```python
# engine/game/components/fish.py
from dataclasses import dataclass
@dataclass
class Fish:
    """
    Domain component tagging an entity as a fish and
    tying it to a species definition.
    """
    species_id: str
```
# === FILE END: engine\game\components\fish.py ===
# === FILE START: engine\game\components\in_tank.py ===
```python
# engine/game/components/in_tank.py
from dataclasses import dataclass
from engine.ecs import EntityId
@dataclass
class InTank:
    """
    Links an entity (fish, pellet, plant, etc.) to a specific tank entity.
    This lets systems operate per tank without global state.
    """
    tank: EntityId
```
# === FILE END: engine\game\components\in_tank.py ===
# === FILE START: engine\game\components\movement_intent.py ===
```python
# engine/game/components/movement_intent.py
from dataclasses import dataclass
@dataclass
class MovementIntent:
    """
    Desired movement for this entity in logical space.
    AI / FSM systems write this.
    MovementSystem reads it and turns it into actual Velocity.
    """
    target_vx: float = 0.0
    target_vy: float = 0.0
```
# === FILE END: engine\game\components\movement_intent.py ===
# === FILE START: engine\game\components\position.py ===
```python
# engine/game/components/position.py
from dataclasses import dataclass
@dataclass
class Position:
    x: float
    y: float
```
# === FILE END: engine\game\components\position.py ===
# === FILE START: engine\game\components\rect_sprite.py ===
```python
# engine/game/components/rect_sprite.py
from dataclasses import dataclass
from typing import Tuple
Color = Tuple[int, int, int]
@dataclass
class RectSprite:
    """
    Very simple sprite definition for MVP:
    - width, height in pixels
    - solid fill color (RGB)
    """
    width: float
    height: float
    color: Color
```
# === FILE END: engine\game\components\rect_sprite.py ===
# === FILE START: engine\game\components\tank.py ===
```python
# engine/game/components/tank.py
from dataclasses import dataclass
@dataclass
class Tank:
    """
    Logical tank properties (identity + rules).
    """
    tank_id: str
    max_fish: int
```
# === FILE END: engine\game\components\tank.py ===
# === FILE START: engine\game\components\tank_bounds.py ===
```python
# engine/game/components/tank_bounds.py
from dataclasses import dataclass
@dataclass
class TankBounds:
    """
    Rectangular area for a tank in *logical* game space (not pixels).
    Movement uses these bounds; rendering will scale logical space
    to the current screen size.
    """
    x: float
    y: float
    width: float
    height: float
```
# === FILE END: engine\game\components\tank_bounds.py ===
# === FILE START: engine\game\components\velocity.py ===
```python
# engine/game/components/velocity.py
from dataclasses import dataclass
@dataclass
class Velocity:
    vx: float
    vy: float
```
# === FILE END: engine\game\components\velocity.py ===
# === FILE START: engine\game\data\__init__.py ===
```python
```
# === FILE END: engine\game\data\__init__.py ===
# === FILE START: engine\game\data\jsonio.py ===
```python
# engine/game/data/jsonio.py
from __future__ import annotations
import json
from pathlib import Path
from typing import Any
# Directory containing all game data files (JSON, etc.)
DATA_DIR = Path(__file__).resolve().parent
def data_path(filename: str) -> Path:
    """
    Return the full path to a data file in this directory.
    Example:
        data_path("species.json") -> .../engine/game/data/species.json
    """
    return DATA_DIR / filename
def load_json(filename: str) -> Any:
    """
    Load a JSON file from the data directory and return the parsed object.
    """
    path = data_path(filename)
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)
```
# === FILE END: engine\game\data\jsonio.py ===
# === FILE START: engine\game\data\species.json ===
```json
{
  "_version": 1,
  "species": {
    "debug_fish": {
      "display_name": "Debug Fish",
      "width": 50,
      "height": 30,
      "color": [200, 240, 255],
      "speed_range": [50.0, 150.0]
    }
  }
}
```
# === FILE END: engine\game\data\species.json ===
# === FILE START: engine\game\data\tanks.json ===
```json
{
  "_version": 1,
  "tanks": {
    "tank_1": {
      "max_fish": 20,
      "bounds": [0.0, 0.0, 1280.0, 720.0],
      "debug_spawn": {
        "count": 8,
        "margin": 50.0
      }
    },
    "small_test_tank": {
      "max_fish": 3,
      "bounds": [100.0, 50.0, 200.0, 200.0],
      "debug_spawn": {
        "count": 2,
        "margin": 10.0
      }
    }
  }
}
```
# === FILE END: engine\game\data\tanks.json ===
# === FILE START: engine\game\factories\__init__.py ===
```python
# engine/game/factories/__init__.py
from .fish_factory import load_species_config, create_fish
from .tank_factory import create_tank, load_tank_config
__all__ = ["load_species_config", "create_fish", "create_tank", "load_tank_config"]
```
# === FILE END: engine\game\factories\__init__.py ===
# === FILE START: engine\game\factories\fish_factory.py ===
```python
# engine/game/factories/fish_factory.py
from __future__ import annotations
import random
from typing import Any, Dict
from engine.ecs import World, EntityId
from engine.game.components import (
    Position,
    Velocity,
    RectSprite,
    Fish,
    Brain,
    MovementIntent,
)
from engine.game.data.jsonio import load_json
SpeciesConfig = Dict[str, Any]
SpeciesConfigMap = Dict[str, SpeciesConfig]
def load_species_config() -> SpeciesConfigMap:
    """
    Load species.json and return the 'species' dict.
    Structure of the json is:
      { "_version": 1, "species": { "debug_fish": { ... } } }
    """
    raw = load_json("species.json")
    species = raw.get("species", {})
    return species
def create_fish(
    world: World,
    species_cfg: SpeciesConfigMap,
    species_id: str,
    x: float,
    y: float,
    rng: random.Random,
) -> EntityId:
    """
    Create a fish entity from species config at a given position.
    Components:
      - Position
      - Velocity (starts at 0; FSM + MovementIntent will drive it)
      - RectSprite (width/height/color from config)
      - Fish (species_id)
      - Brain (FSM state)
      - MovementIntent (AI output)
    """
    spec = species_cfg[species_id]
    width = float(spec["width"])
    height = float(spec["height"])
    color = tuple(spec["color"])  # [r, g, b] -> (r, g, b)
    eid = world.create_entity()
    world.add_component(eid, Position(x=x, y=y))
    # Start with zero velocity; AI will fill in MovementIntent.
    world.add_component(eid, Velocity(vx=0.0, vy=0.0))
    world.add_component(eid, RectSprite(width=width, height=height, color=color))
    world.add_component(eid, Fish(species_id=species_id))
    world.add_component(eid, Brain())
    world.add_component(eid, MovementIntent())
    return eid
```
# === FILE END: engine\game\factories\fish_factory.py ===
# === FILE START: engine\game\factories\tank_factory.py ===
```python
# engine/game/factories/tank_factory.py
from __future__ import annotations
from typing import Any, Dict
from engine.ecs import World, EntityId
from engine.game.components.tank import Tank
from engine.game.components.tank_bounds import TankBounds
from engine.game.data.jsonio import load_json
TankConfig = Dict[str, Any]
def load_tank_config() -> TankConfig:
    """
    Load tanks.json and return the whole structure.
    Expected structure:
        {
          "_version": 1,
          "tanks": {
            "tank_1": {
              "max_fish": 20,
              "bounds": [0.0, 0.0, 1280.0, 720.0],
              "debug_spawn": {
                "count": 8,
                "margin": 50.0
              }
            }
          }
        }
    """
    raw = load_json("tanks.json")
    return raw
def create_tank(
    world: World,
    tank_id: str,
    max_fish: int,
    x: float,
    y: float,
    width: float,
    height: float,
) -> EntityId:
    """
    Create a tank entity with:
      - Tank(tank_id, max_fish)
      - TankBounds(x, y, width, height)
    MovementSystem uses TankBounds to keep fish inside their tank.
    """
    eid = world.create_entity()
    world.add_component(eid, Tank(tank_id=tank_id, max_fish=max_fish))
    world.add_component(eid, TankBounds(x=x, y=y, width=width, height=height))
    return eid
```
# === FILE END: engine\game\factories\tank_factory.py ===
# === FILE START: engine\game\fsm\__init__.py ===
```python
# engine/game/fsm/__init__.py
"""
Finite State Machine (FSM) helpers for the fish game.
"""
from .base_state import FishState
from .idle_state import IdleState
from .cruise_state import CruiseState
__all__ = ["FishState", "IdleState", "CruiseState"]
```
# === FILE END: engine\game\fsm\__init__.py ===
# === FILE START: engine\game\fsm\base_state.py ===
```python
# engine/game/fsm/base.py
from __future__ import annotations
from abc import ABC, abstractmethod
import random
from engine.ecs import EntityId, World
from engine.game.components.fish import Fish
from engine.game.components.brain import Brain
from engine.game.components.movement_intent import MovementIntent
class FishState(ABC):
    """
    Abstract base class for all fish FSM states.
    Each state must implement:
      - name (str): unique identifier ("idle", "cruise", ...)
      - on_enter(...)
      - update(...) -> next state name or None
      - on_exit(...)
    """
    #: Human-/debug-readable state name. Must be unique per state type.
    name: str
    @abstractmethod
    def on_enter(
        self,
        eid: EntityId,
        world: World,
        fish: Fish,
        brain: Brain,
        intent: MovementIntent,
        rng: random.Random,
    ) -> None:
        """
        Called exactly once when entering this state.
        Should:
          - initialise timers on Brain (time_in_state, state_duration)
          - set up initial MovementIntent, if relevant
        """
        raise NotImplementedError
    @abstractmethod
    def update(
        self,
        eid: EntityId,
        world: World,
        fish: Fish,
        brain: Brain,
        intent: MovementIntent,
        dt: float,
        rng: random.Random,
    ) -> str | None:
        """
        Called every frame while in this state.
        Should:
          - read/modify Brain + Intent as needed
          - return:
              * None         -> stay in current state
              * state_name   -> request transition to a different state
        """
        raise NotImplementedError
    @abstractmethod
    def on_exit(
        self,
        eid: EntityId,
        world: World,
        fish: Fish,
        brain: Brain,
        intent: MovementIntent,
        rng: random.Random,
    ) -> None:
        """
        Called once right before leaving this state.
        Use this for cleanup / bookkeeping if needed.
        """
        raise NotImplementedError
```
# === FILE END: engine\game\fsm\base_state.py ===
# === FILE START: engine\game\fsm\cruise_state.py ===
```python
# engine/game/fsm/cruise_state.py
from __future__ import annotations
import math
import random
from typing import Dict, Any
from engine.ecs import EntityId, World
from engine.game.components.fish import Fish
from engine.game.components.brain import Brain
from engine.game.components.movement_intent import MovementIntent
from engine.game.fsm.base_state import FishState
class CruiseState(FishState):
    """
    Cruise state:
      - On enter: pick a random direction and speed (from species config if
        available) and set MovementIntent.
      - Update: after duration, request transition back to "idle".
    """
    name = "cruise"
    def __init__(
        self,
        duration: float,
        species_cfg: Dict[str, Dict[str, Any]] | None,
        default_speed: float,
    ) -> None:
        self._duration = float(duration)
        self._species_cfg = species_cfg or {}
        self._default_speed = float(default_speed)
    def _pick_speed(self, fish: Fish, rng: random.Random) -> float:
        spec = self._species_cfg.get(fish.species_id)
        if spec is None:
            return self._default_speed
        speed_range = spec.get("speed_range")
        if (
            isinstance(speed_range, (list, tuple))
            and len(speed_range) == 2
        ):
            lo, hi = float(speed_range[0]), float(speed_range[1])
            return rng.uniform(lo, hi)
        return self._default_speed
    def on_enter(
        self,
        eid: EntityId,
        world: World,
        fish: Fish,
        brain: Brain,
        intent: MovementIntent,
        rng: random.Random,
    ) -> None:
        brain.time_in_state = 0.0
        brain.state_duration = self._duration
        speed = self._pick_speed(fish, rng)
        angle = rng.uniform(0.0, 2.0 * math.pi)
        intent.target_vx = speed * math.cos(angle)
        intent.target_vy = speed * math.sin(angle)
    def update(
        self,
        eid: EntityId,
        world: World,
        fish: Fish,
        brain: Brain,
        intent: MovementIntent,
        dt: float,
        rng: random.Random,
    ) -> str | None:
        if brain.time_in_state >= brain.state_duration:
            return "idle"
        return None
    def on_exit(
        self,
        eid: EntityId,
        world: World,
        fish: Fish,
        brain: Brain,
        intent: MovementIntent,
        rng: random.Random,
    ) -> None:
        # Nothing special on exit (for now).
        pass
```
# === FILE END: engine\game\fsm\cruise_state.py ===
# === FILE START: engine\game\fsm\idle_state.py ===
```python
# engine/game/fsm/idle_state.py
from __future__ import annotations
import random
from engine.ecs import EntityId, World
from engine.game.components.fish import Fish
from engine.game.components.brain import Brain
from engine.game.components.movement_intent import MovementIntent
from engine.game.fsm.base_state import FishState
class IdleState(FishState):
    """
    Simple idle state:
      - On enter: zero movement, set a fixed duration.
      - Update: after duration, request transition to "cruise".
    """
    name = "idle"
    def __init__(self, duration: float) -> None:
        self._duration = float(duration)
    def on_enter(
        self,
        eid: EntityId,
        world: World,
        fish: Fish,
        brain: Brain,
        intent: MovementIntent,
        rng: random.Random,
    ) -> None:
        brain.time_in_state = 0.0
        brain.state_duration = self._duration
        intent.target_vx = 0.0
        intent.target_vy = 0.0
    def update(
        self,
        eid: EntityId,
        world: World,
        fish: Fish,
        brain: Brain,
        intent: MovementIntent,
        dt: float,
        rng: random.Random,
    ) -> str | None:
        # time_in_state is advanced by the FSM system before this call
        if brain.time_in_state >= brain.state_duration:
            return "cruise"
        return None
    def on_exit(
        self,
        eid: EntityId,
        world: World,
        fish: Fish,
        brain: Brain,
        intent: MovementIntent,
        rng: random.Random,
    ) -> None:
        # Nothing special on exit (for now).
        pass
```
# === FILE END: engine\game\fsm\idle_state.py ===
# === FILE START: engine\game\rules\__init__.py ===
```python
# engine/game/rules/__init__.py
from .population import (
    count_fish_in_tank,
    can_spawn_fish_in_tank,
    spawn_fish_in_tank_if_allowed,
)
__all__ = ["count_fish_in_tank", "can_spawn_fish_in_tank", "spawn_fish_in_tank_if_allowed"]
```
# === FILE END: engine\game\rules\__init__.py ===
# === FILE START: engine\game\rules\population.py ===
```python
# engine/game/rules/population.py
from __future__ import annotations
from typing import Optional
from engine.ecs import World, EntityId
from engine.game.components.fish import Fish
from engine.game.components.in_tank import InTank
from engine.game.components.tank import Tank
from engine.game.factories import create_fish
def count_fish_in_tank(world: World, tank_eid: EntityId) -> int:
    """
    Count how many Fish are in a given tank (by InTank.tank).
    """
    count = 0
    for eid, fish, in_tank in world.view(Fish, InTank):
        if in_tank.tank == tank_eid:
            count += 1
    return count
def can_spawn_fish_in_tank(world: World, tank_eid: EntityId) -> bool:
    """
    Check if the given tank is under its max_fish limit.
    If the tank has no Tank component (shouldn't happen in normal play),
    we treat it as 'no limit' for now.
    """
    tank_store = world.get_components(Tank)
    tank = tank_store.get(tank_eid)
    if tank is None:
        # No tank data -> no cap.
        return True
    current = count_fish_in_tank(world, tank_eid)
    return current < tank.max_fish
def spawn_fish_in_tank_if_allowed(
    world: World,
    tank_eid: EntityId,
    species_cfg,
    species_id: str,
    x: float,
    y: float,
    rng,
) -> Optional[EntityId]:
    """
    Central entry point for spawning fish *per tank*.
    - Checks can_spawn_fish_in_tank.
    - If allowed: creates fish and attaches InTank(tank_eid).
    - If not allowed: returns None (caller can decide what to do).
    """
    if not can_spawn_fish_in_tank(world, tank_eid):
        return None
    fish_eid = create_fish(world, species_cfg, species_id, x, y, rng)
    # Attach tank link
    from engine.game.components.in_tank import InTank  # local import to avoid cycles
    world.add_component(fish_eid, InTank(tank=tank_eid))
    return fish_eid
```
# === FILE END: engine\game\rules\population.py ===
# === FILE START: engine\game\systems\__init__.py ===
```python
# engine/game/systems/__init__.py
from .movement_system import MovementSystem
from .rect_render_system import RectRenderSystem
from .fish_fsm_system import FishFSMSystem
__all__ = ["MovementSystem", "RectRenderSystem", "FishFSMSystem"]
```
# === FILE END: engine\game\systems\__init__.py ===
# === FILE START: engine\game\systems\fish_fsm_system.py ===
```python
# engine/game/systems/fish_fsm_system.py
from __future__ import annotations
import random
from typing import Dict
from engine.ecs import System, World
from engine.resources import ResourceStore
from engine.game.components import Fish, Brain, MovementIntent
from engine.game.fsm.idle_state import IdleState
from engine.game.fsm.cruise_state import CruiseState
class FishFSMSystem(System):
    """
    Full FSM driver for fish movement.
    - Uses Brain to track current state and timing.
    - Uses MovementIntent as the output of the AI.
    - Implements state enter / in / exit semantics via state objects.
    """
    phase = "logic"
    # Default timings; kept as constants so tests can rely on them.
    IDLE_DURATION: float = 1.0
    CRUISE_DURATION: float = 2.0
    DEFAULT_CRUISE_SPEED: float = 80.0
    def __init__(self, resources: ResourceStore) -> None:
        super().__init__(resources)
        # Deterministic RNG for AI
        rng = resources.try_get("rng_ai")
        if rng is None:
            rng = random.Random(12345)
            resources.set("rng_ai", rng)
        self._rng: random.Random = rng
        # Optional species config (for speed ranges)
        species_cfg = resources.try_get("species_config", {})
        # State registry
        self._states: Dict[str, object] = {
            "idle": IdleState(duration=self.IDLE_DURATION),
            "cruise": CruiseState(
                duration=self.CRUISE_DURATION,
                species_cfg=species_cfg,
                default_speed=self.DEFAULT_CRUISE_SPEED,
            ),
        }
    def _enter_state(
        self,
        eid,
        world: World,
        fish: Fish,
        brain: Brain,
        intent: MovementIntent,
    ) -> None:
        """Call on_enter on whatever brain.state currently is."""
        state = self._states.get(brain.state)
        if state is None:
            # Fallback to idle if state name is unknown
            brain.state = "idle"
            state = self._states["idle"]
        state.on_enter(eid, world, fish, brain, intent, self._rng)
    def update(self, world: World, dt: float) -> None:
        for eid, fish, brain, intent in world.view(Fish, Brain, MovementIntent):
            if not brain.initialized:
                self._enter_state(eid, world, fish, brain, intent)
                brain.initialized = True
            brain.time_in_state += dt
            state = self._states.get(brain.state)
            if state is None:
                brain.state = "idle"
                state = self._states["idle"]
            next_state_name = state.update(
                eid, world, fish, brain, intent, dt, self._rng
            )
            if not next_state_name or next_state_name == brain.state:
                continue
            state.on_exit(eid, world, fish, brain, intent, self._rng)
            brain.state = next_state_name
            brain.time_in_state = 0.0
            brain.state_duration = 0.0
            new_state = self._states.get(next_state_name)
            if new_state is None:
                brain.state = "idle"
                new_state = self._states["idle"]
            new_state.on_enter(eid, world, fish, brain, intent, self._rng)
```
# === FILE END: engine\game\systems\fish_fsm_system.py ===
# === FILE START: engine\game\systems\movement_system.py ===
```python
# engine/game/systems/movement_system.py
from __future__ import annotations
from engine.ecs import System, World
from engine.resources import ResourceStore
from engine.game.components.position import Position
from engine.game.components.velocity import Velocity
from engine.game.components.rect_sprite import RectSprite
from engine.game.components.in_tank import InTank
from engine.game.components.tank_bounds import TankBounds
from engine.game.components.movement_intent import MovementIntent
class MovementSystem(System):
    """
    Simple movement + bounce system.
    - Integrates position from velocity.
    - If a MovementIntent exists for an entity, it *drives* its Velocity:
        vel := intent.target_v
    - Bounces rectangles off the *tank bounds* if available.
    - Falls back to full-screen bounds when the entity is not in a tank
      or the tank has no TankBounds.
    """
    phase = "logic"
    def update(self, world: World, dt: float) -> None:
        resources: ResourceStore = self.resources  # type: ignore[assignment]
        # Fallback bounds: whole screen
        screen_w, screen_h = resources.try_get("screen_size", (800, 600))
        # Component stores we’ll look into for tank-based bounds and intents
        in_tank_store = world.get_components(InTank)
        tank_bounds_store = world.get_components(TankBounds)
        intent_store = world.get_components(MovementIntent)
        for eid, pos, vel, sprite in world.view(Position, Velocity, RectSprite):
            # ------------------------------------------------------------
            # 1) Apply MovementIntent (if present) to velocity
            # ------------------------------------------------------------
            intent = intent_store.get(eid)
            if intent is not None:
                vel.vx = intent.target_vx
                vel.vy = intent.target_vy
            # ------------------------------------------------------------
            # 2) Determine which bounds apply: tank bounds or screen
            # ------------------------------------------------------------
            bounds = None
            in_tank = in_tank_store.get(eid)
            if in_tank is not None:
                bounds = tank_bounds_store.get(in_tank.tank)
            if bounds is not None:
                # Use the tank's rectangle
                left = float(bounds.x)
                top = float(bounds.y)
                right = float(bounds.x + bounds.width)
                bottom = float(bounds.y + bounds.height)
            else:
                # No tank / no TankBounds: fall back to screen rect
                left = 0.0
                top = 0.0
                right = float(screen_w)
                bottom = float(screen_h)
            # Effective motion bounds for the *top-left* of the sprite
            min_x = left
            max_x = right - sprite.width
            min_y = top
            max_y = bottom - sprite.height
            # ------------------------------------------------------------
            # 3) Integrate position
            # ------------------------------------------------------------
            pos.x += vel.vx * dt
            pos.y += vel.vy * dt
            # ------------------------------------------------------------
            # 4) Bounce against bounds
            # ------------------------------------------------------------
            # Horizontal
            if pos.x < min_x:
                pos.x = min_x
                vel.vx = -vel.vx
            elif pos.x > max_x:
                pos.x = max_x
                vel.vx = -vel.vx
            # Vertical
            if pos.y < min_y:
                pos.y = min_y
                vel.vy = -vel.vy
            elif pos.y > max_y:
                pos.y = max_y
                vel.vy = -vel.vy
```
# === FILE END: engine\game\systems\movement_system.py ===
# === FILE START: engine\game\systems\rect_render_system.py ===
```python
# engine/game/systems/rect_render_system.py
from __future__ import annotations
from engine.ecs import System, World
from engine.resources import ResourceStore
from engine.game.components.position import Position
from engine.game.components.rect_sprite import RectSprite
class RectRenderSystem(System):
    """
    Render all RectSprite entities as colored rectangles.
    Works in two spaces:
      - Logical space: Position / RectSprite.width/height.
      - Render space: actual screen pixels (from screen_size).
    We compute a scale factor between logical_size and screen_size
    and draw scaled rectangles, so resizing the window scales the
    whole game world.
    """
    phase = "render"
    def update(self, world: World, dt: float) -> None:
        resources: ResourceStore = self.resources  # type: ignore[assignment]
        renderer = resources.try_get("renderer")
        if renderer is None:
            return
        # Sizes
        screen_w, screen_h = resources.try_get("screen_size", (800.0, 600.0))
        logical_w, logical_h = resources.try_get("logical_size", (screen_w, screen_h))
        # Avoid division by zero
        if logical_w <= 0:
            logical_w = screen_w
        if logical_h <= 0:
            logical_h = screen_h
        # Non-uniform scaling (simplest: fills the window in both axes)
        scale_x = screen_w / logical_w
        scale_y = screen_h / logical_h
        # Clear screen first
        renderer.clear()
        # Draw all entities that have Position + RectSprite
        for eid, pos, sprite in world.view(Position, RectSprite):
            x_px = pos.x * scale_x
            y_px = pos.y * scale_y
            w_px = sprite.width * scale_x
            h_px = sprite.height * scale_y
            renderer.draw_rect(x_px, y_px, w_px, h_px, sprite.color)
        # Present frame
        renderer.present()
```
# === FILE END: engine\game\systems\rect_render_system.py ===
